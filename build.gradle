import org.apache.tools.ant.filters.ReplaceTokens

plugins {
	id 'java'
	id 'org.springframework.boot' version '4.0.2'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'io.github.mjyoun'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

def environments = ['dev', 'prod', 'local', 'test', 'stage']

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(25)
	}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-log4j2'
	implementation 'com.fasterxml.jackson.dataformat:jackson-dataformat-yaml'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

configurations {
	all {
		exclude group: 'org.springframework.boot', module: 'spring-boot-starter-logging'
	}
}

tasks.named('test') {
	useJUnitPlatform()
}

bootJar {
	// ì‹¤í–‰ ê°€ëŠ¥í•œ JAR ìƒì„± ì‹œ ì„¤ì • íŒŒì¼ ì œì™¸ (ì™¸ë¶€ config ì‚¬ìš© ìœ„í•¨)
	// src/main/resourcesì— ìˆëŠ” application.yml ë“±ì„ ì œì™¸í•˜ì—¬ ë¹Œë“œ ê²°ê³¼ë¬¼ì„ í™˜ê²½ ë…ë¦½ì ìœ¼ë¡œ ë§Œë“¦
	exclude 'application*.yml', 'application*.properties', 'log4j2*'
}

// ë°°í¬ìš© íŒ¨í‚¤ì§€ ìƒì„± íƒœìŠ¤í¬
// ì‹¤í–‰ ê°€ëŠ¥í•œ JAR, ì„¤ì • íŒŒì¼(config), ì‹œì‘/ì¢…ë£Œ ìŠ¤í¬ë¦½íŠ¸(bin)ë¥¼ ë¬¶ì–´ zip íŒŒì¼ë¡œ ìƒì„±
// 'package'ëŠ” ì˜ˆì•½ì–´ì¼ ìˆ˜ ìˆìœ¼ë¯€ë¡œ ë”°ì˜´í‘œë¡œ ê°ì‹¸ì„œ Task ì´ë¦„ìœ¼ë¡œ ì •ì˜
task 'package'(type: Zip) {
	dependsOn bootJar
	duplicatesStrategy = DuplicatesStrategy.EXCLUDE

	def distName = "${project.name}-${project.version}"
	def envSuffix = ""

	// 1. í™˜ê²½ë³„ íŒŒì¼ (Environment Specific Files)
	// ë¨¼ì € ì¶”ê°€ëœ íŒŒì¼ì´ ìš°ì„ ìˆœìœ„ë¥¼ ê°€ì§ (EXCLUDE ì „ëµ)
	if (project.hasProperty('env')) {
		def env = project.property('env')
		envSuffix = "-${env}"
		
		from("config/$env") {
			into 'config'
			rename { String filename ->
				filename.replace("-${env}", "")
			}
		}
		
		from("scripts/$env") {
			into 'bin'
			filter(ReplaceTokens, tokens: [appName: project.name])
			rename { String filename ->
				filename.replace("-${env}", "")
			}
		}
	}
	
	doFirst {
		if (project.hasProperty('env')) {
			println "ğŸ“¦ ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± ì¤‘ (í™˜ê²½: ${project.property('env')})"
		} else {
			println "ğŸ“¦ ê¸°ë³¸ í™˜ê²½(dev) ë˜ëŠ” ì§€ì •ë˜ì§€ ì•Šì€ í™˜ê²½ìœ¼ë¡œ ë°°í¬ íŒ¨í‚¤ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤."
		}
	}

	// 2. ê¸°ë³¸ íŒŒì¼ (Base Files)
	// ì´ë¯¸ ì¶”ê°€ëœ íŒŒì¼(í™˜ê²½ë³„ íŒŒì¼)ì´ ìˆë‹¤ë©´ ì´ íŒŒì¼ë“¤ì€ ë¬´ì‹œë¨
	from('config') {
		into 'config'
		// í™˜ê²½ë³„ í´ë”ê°€ Zip ë£¨íŠ¸ì— ê·¸ëŒ€ë¡œ ë“¤ì–´ê°€ëŠ” ê²ƒì„ ë°©ì§€ (ê¹”ë”í•œ íŒ¨í‚¤ì§•)
		exclude environments
		if (project.hasProperty('env')) {
			exclude project.property('env')
		}
	}

	from('scripts') {
		into 'bin'
		filter(ReplaceTokens, tokens: [appName: project.name])
		exclude environments
		if (project.hasProperty('env')) {
			exclude project.property('env')
		}
	}

	archiveFileName = "${distName}${envSuffix}.dist.zip"
	destinationDirectory = file("${buildDir}/dist")

	// 3. Libs
	from(bootJar.outputs.files) {
		into 'libs'
	}
}

// í‘œì¤€ 'build' íƒœìŠ¤í¬ ì‹¤í–‰ ì‹œ 'package' íƒœìŠ¤í¬ë„ í•¨ê»˜ ì‹¤í–‰ë˜ë„ë¡ ì„¤ì •
tasks.named('build') {
	dependsOn 'package'
}

// Docker ë¹Œë“œë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ì™€ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.
task prepareDockerContext {
	dependsOn 'package'
	group = 'build'
	description = 'Docker ë¹Œë“œë¥¼ ìœ„í•œ ì»¨í…ìŠ¤íŠ¸ì™€ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ë¥¼ ì¤€ë¹„í•©ë‹ˆë‹¤.'

	doLast {
		def distName = "${project.name}-${project.version}"
		def envSuffix = project.hasProperty('env') ? "-${project.property('env')}" : ""
		def distZipName = "${distName}${envSuffix}.dist.zip"
		
		def dockerContext = file("${buildDir}/docker-build")
		def dockerDistDir = file("${buildDir}/docker-dist") 
		
		println "ğŸ³ === Docker ë¹Œë“œ ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„ ì‹œì‘ ==="
		
		// 1. ì´ˆê¸°í™” (Clean & Prepare)
		delete dockerContext
		mkdir dockerContext
		
		delete dockerDistDir
		mkdir dockerDistDir

		// 2. ë°°í¬ íŒ¨í‚¤ì§€(Zip)ì—ì„œ Docker ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„
		def distZipFile = file("${buildDir}/dist/${distZipName}")
		if (!distZipFile.exists()) {
			throw new GradleException("ë°°í¬ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $distZipFile")
		}

		copy {
			from zipTree(distZipFile)
			into dockerContext
		}

		// Dockerfile ë³µì‚¬
		def dockerfilePath = file('docker/Dockerfile')
		if (!dockerfilePath.exists()) {
			throw new GradleException("Dockerfileì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: $dockerfilePath")
		}
		copy {
			from dockerfilePath
			into dockerContext
		}
		
		// 3. ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ë° ì„¤ì • íŒŒì¼ ë³µì‚¬ (docker-dist)
		println "ğŸ“‚ ë°°í¬ ìŠ¤í¬ë¦½íŠ¸ ë° ì„¤ì • íŒŒì¼ ë³µì‚¬ ì¤‘... (${dockerDistDir})"
		
		// ì´ë¯¸ì§€ ì´ë¦„ ê²°ì • (Strategy 1, 2, 3 ì§€ì›ì„ ìœ„í•œ ë™ì  íƒœê·¸)
		def registry = project.hasProperty('dockerRegistry') ? project.property('dockerRegistry') : ""
		def tag = project.hasProperty('dockerImageTag') ? project.property('dockerImageTag') : "latest"
		def imageName = "${project.name}:${tag}"
		
		if (registry) {
			// ì˜ˆ: my-reg.com/my-project:v1.0.0
			imageName = "${registry}/${project.name}:${tag}"
			// ë ˆì§€ìŠ¤íŠ¸ë¦¬ URLì´ ìŠ¬ë˜ì‹œë¡œ ëë‚˜ì§€ ì•Šìœ¼ë©´ ì¶”ê°€ (ë‹¨, ë¹„ì–´ìˆì§€ ì•Šì„ ë•Œ)
			if (!registry.endsWith('/')) {
				imageName = "${registry}/${project.name}:${tag}"
			}
		}
		println "ğŸ¯ ëŒ€ìƒ Docker ì´ë¯¸ì§€: ${imageName}"
		
		// í™˜ê²½ë³„ docker-compose.yml ì„ íƒ
		def env = project.hasProperty('env') ? project.property('env') : 'dev'
		def envComposeFile = file("docker/${env}/docker-compose-${env}.yml")
		def baseComposeFile = file("docker/docker-compose.yml")
		
		def composeFile = envComposeFile.exists() ? envComposeFile : baseComposeFile
		
		if (!composeFile.exists()) {
			throw new GradleException("docker-compose.yml íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í™•ì¸í•œ ê²½ë¡œ: $envComposeFile, $baseComposeFile")
		}
		
		println "ğŸ“„ ì‚¬ìš©ëœ docker-compose íŒŒì¼: ${composeFile.absolutePath}"
		
		copy {
			from composeFile
			into dockerDistDir
			rename { 'docker-compose.yml' }
			filter(ReplaceTokens, tokens: [
				appName: project.name.toString(), 
				LOG_PATH: ('/var/log/' + project.name).toString(),
				dockerImage: imageName.toString()
			])
		}
		
		// ìŠ¤í¬ë¦½íŠ¸ ë³µì‚¬ (install, uninstall, utils, cron)
		['docker/install_docker_service.sh', 'docker/uninstall_docker_service.sh', 'scripts/utils.sh'].each { src ->
			def f = file(src)
			if (f.exists()) {
				copy {
					from f
					into dockerDistDir
					filter(ReplaceTokens, tokens: [appName: project.name])
				}
			}
		}
		
		def cronDir = file('scripts/cron')
		if (cronDir.exists()) {
			copy {
				from cronDir
				into "${dockerDistDir}/cron"
			}
		}
		
		// .app-env.properties ë³µì‚¬
		def envPropsFile = file("scripts/${env}/.app-env-${env}.properties")
		def basePropsFile = file("scripts/.app-env.properties")
		def propsFile = envPropsFile.exists() ? envPropsFile : basePropsFile
		
		if (propsFile.exists()) {
			copy {
				from propsFile
				into dockerDistDir
				rename { '.app-env.properties' }
			}
		}
		
		println "âœ… Docker ì»¨í…ìŠ¤íŠ¸ ì¤€ë¹„ ì™„ë£Œ"
	}
}

// Docker ì´ë¯¸ì§€ë¥¼ ë¡œì»¬ ë°ëª¬ì— ë¹Œë“œí•©ë‹ˆë‹¤. (Server-side Buildìš©)
task dockerBuildImage {
	dependsOn prepareDockerContext
	group = 'build'
	description = 'Docker ì´ë¯¸ì§€ë¥¼ ë¡œì»¬ ë°ëª¬ì— ë¹Œë“œí•©ë‹ˆë‹¤. (Server-side Buildìš©)'

	doLast {
		def registry = project.hasProperty('dockerRegistry') ? project.property('dockerRegistry') : ""
		def tag = project.hasProperty('dockerImageTag') ? project.property('dockerImageTag') : "latest"
		
		def fullImageName = "${project.name}:${tag}"
		if (registry) {
			if (!registry.endsWith('/')) registry += '/'
			fullImageName = "${registry}${project.name}:${tag}"
		}

		def dockerContext = file("${buildDir}/docker-build")
		
		println "ğŸ”¨ === Docker ì´ë¯¸ì§€ ë¹Œë“œ ì‹œì‘ ==="
		println "ğŸ”– ëŒ€ìƒ ì´ë¯¸ì§€ íƒœê·¸: $fullImageName"
		
		// docker build ì‹¤í–‰
		// ë¦¬ëˆ…ìŠ¤ ë°°í¬ë¥¼ ìœ„í•´ amd64 í”Œë«í¼ ëª…ì‹œ (í•„ìš”ì‹œ ìˆ˜ì • ê°€ëŠ¥)
		def buildProc = ['docker', 'build', '--platform', 'linux/amd64', '-t', fullImageName, '.'].execute(null, dockerContext)
		buildProc.waitForProcessOutput(System.out, System.err)
		
		if (buildProc.exitValue() != 0) {
			throw new GradleException("Docker ë¹Œë“œ ì‹¤íŒ¨")
		}
		
		println "âœ¨ === Docker ì´ë¯¸ì§€ ë¹Œë“œ ì„±ê³µ: $fullImageName ==="
		println "ğŸ“‚ ë°°í¬ íŒŒì¼ ê²½ë¡œ: ${buildDir}/docker-dist"
		
		if (!registry) {
			println "ğŸš€ ì‹¤í–‰ ë°©ë²• (Strategy 2): cd ${buildDir}/docker-dist && docker-compose up -d"
		}
	}
}

// Docker ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•˜ê³  ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— Pushí•©ë‹ˆë‹¤. (Strategy 3)
task dockerPushImage {
	dependsOn dockerBuildImage
	group = 'build'
	description = 'Docker ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•˜ê³  ë ˆì§€ìŠ¤íŠ¸ë¦¬ì— Pushí•©ë‹ˆë‹¤. (Strategy 3)'

	doLast {
		def registry = project.hasProperty('dockerRegistry') ? project.property('dockerRegistry') : ""
		if (!registry) {
			throw new GradleException("Pushë¥¼ í•˜ë ¤ë©´ dockerRegistry ì†ì„±ì´ í•„ìš”í•©ë‹ˆë‹¤. ì˜ˆ: -PdockerRegistry=my.reg.com")
		}
		
		def tag = project.hasProperty('dockerImageTag') ? project.property('dockerImageTag') : "latest"
		if (!registry.endsWith('/')) registry += '/'
		
		def fullImageName = "${registry}${project.name}:${tag}"
		
		println "â˜ï¸ === Docker ì´ë¯¸ì§€ Push ì‹œì‘ ==="
		println "ğŸ“¤ ì´ë¯¸ì§€ Push ì¤‘: $fullImageName"
		
		def pushProc = ['docker', 'push', fullImageName].execute()
		pushProc.waitForProcessOutput(System.out, System.err)
		
		if (pushProc.exitValue() != 0) {
			throw new GradleException("Docker Push ì‹¤íŒ¨. ë ˆì§€ìŠ¤íŠ¸ë¦¬ ë¡œê·¸ì¸ ìƒíƒœë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.")
		}
		
		println "âœ… === Docker ì´ë¯¸ì§€ Push ì™„ë£Œ ==="
		println "ğŸ“‚ ë°°í¬ íŒŒì¼ ê²½ë¡œ (docker-compose.yml, scripts): ${buildDir}/docker-dist"
		println "ğŸš€ ì„œë²„ì—ì„œ 'build/docker-dist' íŒŒì¼ë“¤ì„ ì‚¬ìš©í•˜ì—¬ ë°°í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."
	}
}

// Docker ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•˜ê³  ë°°í¬ìš© ìŠ¤í¬ë¦½íŠ¸ì™€ í•¨ê»˜ Zipìœ¼ë¡œ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤. (Strategy 1)
task dockerBuild {
	dependsOn dockerBuildImage
	group = 'build'
	description = 'Docker ì´ë¯¸ì§€ë¥¼ ë¹Œë“œí•˜ê³  ë°°í¬ìš© ìŠ¤í¬ë¦½íŠ¸ì™€ í•¨ê»˜ Zipìœ¼ë¡œ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤. (Strategy 1)'

	doLast {
		def envSuffix = project.hasProperty('env') ? "-${project.property('env')}" : ""
		def dockerDistZipName = "${project.name}-docker${envSuffix}.zip" 
		def dockerDistDir = file("${buildDir}/docker-dist")
		
		// Strategy 1: í•­ìƒ ë¡œì»¬ Project Name íƒœê·¸ë¡œ ì €ì¥
		if (project.hasProperty('dockerRegistry')) {
			println "âš ï¸ ê²½ê³ : 'dockerBuild' íƒœìŠ¤í¬ëŠ” Strategy 1 (ë¡œì»¬ ë¹Œë“œ/íŒ¨í‚¤ì§•) ì „ìš©ì…ë‹ˆë‹¤. 'dockerRegistry' ì†ì„±ì€ ë¬´ì‹œë©ë‹ˆë‹¤."
		}

		def tagName = "${project.name}:latest"
		def tarName = "${project.name}.tar"

		println "ğŸ“¦ === Docker ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± ì‹œì‘ (Strategy 1) ==="
		
		// Export Docker Image (docker save)
		println "ğŸ’¾ Docker ì´ë¯¸ì§€ ì¶”ì¶œ ì¤‘ (docker save) -> ${dockerDistDir}/${tarName}..."
		
		def saveProc = ['docker', 'save', '-o', "${dockerDistDir}/${tarName}", tagName].execute()
		saveProc.waitForProcessOutput(System.out, System.err)

		if (saveProc.exitValue() != 0) {
			throw new GradleException("Docker Save ì‹¤íŒ¨. Strategy 1ì„ ì‚¬ìš©í•˜ë ¤ë©´ registry ì˜µì…˜ ì—†ì´ ì‹¤í–‰í•˜ì„¸ìš”.")
		}
		
		// Create Final Zip
		println "ğŸ—œï¸ ìµœì¢… ë°°í¬ìš© Zip ìƒì„± ì¤‘: ${buildDir}/dist/${dockerDistZipName}"
		ant.zip(destfile: "${buildDir}/dist/${dockerDistZipName}", basedir: dockerDistDir)
		
		println "âœ… === Docker ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± ì™„ë£Œ: ${buildDir}/dist/${dockerDistZipName} ==="
	}
}

// Kubernetes ë°°í¬ìš© ë§¤ë‹ˆí˜ìŠ¤íŠ¸(YAML) íŒ¨í‚¤ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤. (Strategy 3)
task k8sBuild(type: Zip) {
	dependsOn dockerBuildImage
	group = 'distribution'
	description = 'Kubernetes ë°°í¬ìš© ë§¤ë‹ˆí˜ìŠ¤íŠ¸(YAML) íŒ¨í‚¤ì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.'

	def distName = "${project.name}-k8s"
	def envSuffix = ""
	
	if (project.hasProperty('env')) {
		def env = project.property('env')
		envSuffix = "-${env}"
	}
	
	archiveFileName = "${distName}${envSuffix}.zip"
	destinationDirectory = file("${buildDir}/dist")
	
	// Strategy 3 ì§€ì›ì„ ìœ„í•œ ì´ë¯¸ì§€ íƒœê·¸ ê²°ì • ë¡œì§ (prepareDockerContextì™€ ë™ì¼)
	def registry = project.hasProperty('dockerRegistry') ? project.property('dockerRegistry') : ""
	def tag = project.hasProperty('dockerImageTag') ? project.property('dockerImageTag') : "latest"
	def imageName = "${project.name}:${tag}"
	
	if (registry) {
		imageName = "${registry}/${project.name}:${tag}"
		if (!registry.endsWith('/')) {
			imageName = "${registry}/${project.name}:${tag}"
		}
	}

	from('k8s') {
		into 'k8s'
		filter(ReplaceTokens, tokens: [
			appName: project.name.toString(),
			dockerImage: imageName.toString()
		])
	}
	
	doFirst {
		if (project.hasProperty('env')) {
			def env = project.property('env')
			println "â˜¸ï¸ K8s ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± ì¤‘ (í™˜ê²½: $env)"
		}
		println "ğŸ¯ K8s ëŒ€ìƒ Docker ì´ë¯¸ì§€: ${imageName}"
	}

	doLast {
		println "âœ… === K8s ë°°í¬ íŒ¨í‚¤ì§€ ìƒì„± ì™„ë£Œ: ${destinationDirectory.get()}/${archiveFileName.get()} ==="
	}
}